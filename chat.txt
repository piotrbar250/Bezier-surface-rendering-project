#pragma once
#include <SFML/Graphics.hpp>
#include "Bezier.hpp"
#include "Math.hpp"
#include "global.hpp"
#include "Bitmap.hpp"
#include "Bezier.hpp"
#include "LightSource.hpp"
//LambertianReflectanceProcessor

class PhongReflectionProcessor
{
public:
    Bezier& bezier;
    LightSource& lightSource;
    float kd = 1, ks = 1;
    Point3d Il = {1,1,1}, Io = {0,0.2,0};
    Point3d N, L;
    Point3d R, V = {0, 0, 1};
    float m = 1;
    
    PhongReflectionProcessor(Bezier& bezier, LightSource& lightSource) : bezier(bezier), lightSource(lightSource)
    {

    }

    Color computePixelColor(float x, float y, float z)
    {
        N = cross(bezier.tangentX(x, y), bezier.tangentY(x, y));
        L = Point3d(lightSource.x, lightSource.y, lightSource.z) - Point3d(x, y, z);

        N = N.normalized();
        L = L.normalized();

        R = (N-L) * 2 * dot(N, L);
        R = R.normalized();
        Point3d Ip = Il * Io * kd * max(0.0f, dot(N, L));
        Ip = Ip + Il * Io * dot(V,R);

        return Color(Ip.x*255, Ip.y*255, Ip.z*255);
    }
};




#pragma once
#include <SFML/Graphics.hpp>
#include <iostream>
#include "Math.hpp"
#include "global.hpp"


using namespace std;
using namespace sf;
using namespace Math;

class Bezier
{
public:

    float Z[4][4];
    int prepZ[4][4] = {
        {1,0,0,0},
        {0,0,0,0},
        {0,0,0,0},
        {0,0,0,0}
    };    
    /*
        prepZ visualizes control points
        Z - control points:

        z03 z13 z23 z33
        z02 z12 z22 z32
        z01 z11 z21 z31
        z00 z10 z20 z30
    */

    void genZ()
    {
        for(int k = 0; k < 4; k++)
            Z[k][0] = prepZ[3][k]; 
        for(int k = 0; k < 4; k++)
            Z[k][1] = prepZ[2][k]; 
        for(int k = 0; k < 4; k++)
            Z[k][2] = prepZ[1][k];  
        for(int k = 0; k < 4; k++)
            Z[k][3] = prepZ[0][k];  
    }

    Bezier()
    {
        genZ();
    }

    float B(int i, int n, float argument) // bezierCoefficient
    {
        return Math::binomial(n, i) * Math::power(argument, i) * Math::power(1.0f - argument, 3 - i);
    }

    float z(float x, float y)
    {
        float value = 0;
        for(int i = 0; i <= 3; i++ )
            for(int j = 0; j <= 3; j++)
            {
                value += (Z[i][j] * B(i, 3,  x) * B(j, 3, y));
            }
        return value;
    }

    Point3d tangentX(float u, float v)
    {
        int n = 3, m = 3;

        float value = 0;
        for(int i = 0; i <= n-1; i++)
            for(int j = 0; j <= m; j++)
                value += (Z[i+1][j] - Z[i][j]) * B(i, n-1, u) * B(j, m, v);

        return Point3d(1, 0, value);
    }

    Point3d tangentY(float u, float v)
    {
        int n = 3, m = 3;
        
        float value = 0;
        for(int i = 0; i <= n; i++)
            for(int j = 0; j <= m-1; j++)
                value += (Z[i][j+1] - Z[i][j]) * B(i, n, u) * B(j, m-1, v);

        return Point3d(0, 1, value);
    }
};

#pragma once
#include <SFML/Graphics.hpp>
#include <iostream>

using namespace std;
using namespace sf;

namespace Math
{
    class Point3d
    {
        public:
        float x, y, z;
        Point3d() {}
        Point3d(float x, float y, float z) : x(x), y(y), z(z) {}

        friend Point3d cross(const Point3d& a, const Point3d&b)
        {
            return Point3d(
                a.y*b.z - a.z*b.y,
                a.z*b.x - a.x*b.z,
                a.x*b.y - a.y*b.x
            );
        }
        friend float dot(const Point3d& a, const Point3d&b)
        {
            return a.x* b.x + a.y*b.y + a.z*b.z;
        }
        Point3d operator*(const Point3d&b) const
        {
            return Point3d(
                x * b.x,
                y * b.y,
                z * b.z
            );
        }
        Point3d operator *(float k) const
        {
            return Point3d(
                k*x,
                k*y,
                k*z
            );
        }
        Point3d operator +(const Point3d&b) const
        {
            return Point3d(
                x + b.x,
                y + b.y,
                z + b.z
            );
        }
        Point3d operator -(const Point3d&b) const
        {
            return Point3d(
                x - b.x,
                y - b.y,
                z - b.z
            );
        }
        float norm() const
        {
            return sqrt(x*x + y*y + z*z);
        }
        Point3d normalized() const
        {
            float _norm = norm();
            return Point3d(
                x / _norm,
                y / _norm,
                z / _norm
            );
        }
    };

    int binomialCoeff(int n, int k)
    {
        int res = 1;

        if (k > n - k)
            k = n - k;

        for (int i = 0; i < k; ++i)
        {
            res *= (n - i);
            res /= (i + 1);
        }
        return res;
    }

    int binomial_2[3] = {1, 2, 1}; 
    int binomial_3[4] = {1, 3, 3, 1};

    int binomial(int n, int k)
    {
        if (n == 2 && k >= 0 && k < 3)
            return binomial_2[k];
        else if (n == 3 && k >= 0 && k < 4)
            return binomial_3[k];
        else
            return 0;
    }

    float power(float a, int b)
    {
        // 0 <= b <= 3
        if (b < 0 || b > 3)
        {
            cout << "Exponent out of allowed range (0-3)." << endl;
            exit(1);
            return -1;
        }

        switch (b)
        {
        case 0:
            return 1;
        case 1:
            return a;
        case 2:
            return a * a;
        case 3:
            return a * a * a;
        default:
        {
            cout << "error" << endl;
            return -1;
        }
        }
    }

};


#pragma once
#include <SFML/Graphics.hpp>
#include <iostream>

using namespace std;
using namespace sf;

namespace Math
{
    class Point3d
    {
        public:
        float x, y, z;
        Point3d() {}
        Point3d(float x, float y, float z) : x(x), y(y), z(z) {}

        friend Point3d cross(const Point3d& a, const Point3d&b)
        {
            return Point3d(
                a.y*b.z - a.z*b.y,
                a.z*b.x - a.x*b.z,
                a.x*b.y - a.y*b.x
            );
        }
        friend float dot(const Point3d& a, const Point3d&b)
        {
            return a.x* b.x + a.y*b.y + a.z*b.z;
        }
        Point3d operator*(const Point3d&b) const
        {
            return Point3d(
                x * b.x,
                y * b.y,
                z * b.z
            );
        }
        Point3d operator *(float k) const
        {
            return Point3d(
                k*x,
                k*y,
                k*z
            );
        }
        Point3d operator +(const Point3d&b) const
        {
            return Point3d(
                x + b.x,
                y + b.y,
                z + b.z
            );
        }
        Point3d operator -(const Point3d&b) const
        {
            return Point3d(
                x - b.x,
                y - b.y,
                z - b.z
            );
        }
        float norm() const
        {
            return sqrt(x*x + y*y + z*z);
        }
        Point3d normalized() const
        {
            float _norm = norm();
            return Point3d(
                x / _norm,
                y / _norm,
                z / _norm
            );
        }
    };

    int binomialCoeff(int n, int k)
    {
        int res = 1;

        if (k > n - k)
            k = n - k;

        for (int i = 0; i < k; ++i)
        {
            res *= (n - i);
            res /= (i + 1);
        }
        return res;
    }

    int binomial_2[3] = {1, 2, 1}; 
    int binomial_3[4] = {1, 3, 3, 1};

    int binomial(int n, int k)
    {
        if (n == 2 && k >= 0 && k < 3)
            return binomial_2[k];
        else if (n == 3 && k >= 0 && k < 4)
            return binomial_3[k];
        else
            return 0;
    }

    float power(float a, int b)
    {
        // 0 <= b <= 3
        if (b < 0 || b > 3)
        {
            cout << "Exponent out of allowed range (0-3)." << endl;
            exit(1);
            return -1;
        }

        switch (b)
        {
        case 0:
            return 1;
        case 1:
            return a;
        case 2:
            return a * a;
        case 3:
            return a * a * a;
        default:
        {
            cout << "error" << endl;
            return -1;
        }
        }
    }

};


computePixelColor returns wrong value 